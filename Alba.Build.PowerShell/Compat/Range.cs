//<auto-generated/>
#nullable enable
#pragma warning disable

#if !NETCOREAPP3_0_OR_GREATER && !NET5_0_OR_GREATER

using System.Runtime.CompilerServices;

namespace System;

internal readonly struct Range(Index start, Index end) : IEquatable<Range>
{
    public Index Start { get; } = start;
    public Index End { get; } = end;

    public static Range StartAt(Index start) => new(start, Index.End);

    public static Range EndAt(Index end) => new(Index.Start, end);

    public static Range All => new(Index.Start, Index.End);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public (int Offset, int Length) GetOffsetAndLength(int length)
    {
        Index startIndex = Start;
        int start = startIndex.IsFromEnd ? length - startIndex.Value : startIndex.Value;

        Index endIndex = End;
        int end = endIndex.IsFromEnd ? length - endIndex.Value : endIndex.Value;

        if ((uint)end > (uint)length || (uint)start > (uint)end)
            throw new ArgumentOutOfRangeException(nameof(length));

        return (start, end - start);
    }

    public bool Equals(Range other) => other.Start.Equals(Start) && other.End.Equals(End);

    public override bool Equals(object? other) => other is Range r && r.Equals(other);

    public override int GetHashCode() => HashCode.Combine(Start, End);

    public override string ToString() => $"{Start}..{End}";
}

#endif